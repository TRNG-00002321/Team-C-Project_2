pipeline {
    agent any
    environment {
        APP_NAME = 'employee'
        APP_VERSION = '1.1.0'
        DOCKER_IMAGE = "${APP_NAME}"
        DOCKER_TAG = "${BUILD_NUMBER}"
        
    }
    

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
        disableConcurrentBuilds()
    }
    parameters {
        booleanParam(
            name: "TEST_MODE", 
            defaultValue: true,
            description: 'Run test exectution'
        )    }

    stages {
        stage('Initialize'){
            steps {
                sh """
                echo "==========================================="
                echo "  Jenkins Pipeline - Employee Application"
                echo "==========================================="
                echo " Application: ${APP_NAME} v${APP_VERSION}"
                echo " Build Number: ${BUILD_NUMBER}"
                echo " Workspace: ${WORKSPACE}"
                echo "==========================================="
                """
            }
        }
        stage('Checkout') {
            steps {
                echo 'Checking out source code...'
                checkout scm
                echo "Verifying files in workspace:"
                sh 'ls -la'
            }
        }
        stage('Unit Tests') {
            steps {
                echo 'ðŸ§ª Running Python Unit Tests with Allure...'
                sh """
                    mkdir -p allure-results test-results
                    
                    docker run --rm \
                        -v ${WORKSPACE}:/employee \
                        -w /employee \
                        python:3.12-slim \
                        sh -c "pip install -r requirements.txt && \
                            pytest tests/unit -v \
                            --alluredir=/employee/allure-results \
                            --junitxml=/employee/test-results/unit-results.xml"
                """
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'test-results/*.xml'
                }
            }
        }
        stage('Integration Tests') {
            when {
                expression { params.TEST_MODE == true }
            }
            // steps {
            //     dir('employee') {
            //         echo 'Running tests...'
            //         sh """
            //             docker build --target test -t ${DOCKER_IMAGE}-test:${DOCKER_TAG} .
            //             docker run -v ${WORKSPACE}/allure-results:/employee/allure-results ${DOCKER_IMAGE}-test:${DOCKER_TAG}
            //         """
            //     }
            // }
            steps {
                dir('employee') {
                    echo 'Running tests with Docker Compose...'
                    sh "docker compose -f docker-compose-v2.yml up --build --abort-on-container-exit --exit-code-from behave-tests"
                }
            }
            post {
                always {
                    dir('employee') {
                        sh "docker compose -f docker-compose-v2.yml down -v"
                    }

                    // Publish test results
                    junit allowEmptyResults: true, testResults: '**/test-results/*.xml'
                }
                success {
                    echo 'All Tests Passesd!'
                }
                failure {
                    echo 'Some Tests Failed!'
                }
            }
        }
        stage('Build Docker Image') {
            steps {
                dir('employee') {
                    echo 'Building Docker image...'
                    sh """
                    docker build --target production -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
                    """
                    echo 'Docker image built successfully:'
                    sh "docker images | grep ${DOCKER_IMAGE} || true"
                }
            }
        }
        stage('Test Docker Image') {
            steps {
                dir('employee') {
                    echo 'Testing Docker image...'
                    sh """
                    CONTAINER_ID=\$(docker run -d -p 5000:5000 ${DOCKER_IMAGE}:${DOCKER_TAG})
                    sleep 5
                    RESPONSE_CODE=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/health)
                    docker stop \$CONTAINER_ID
                    docker rm \$CONTAINER_ID
                    echo "Health check response code: \$RESPONSE_CODE"
                    if [ "\$RESPONSE_CODE" -ne 200 ]; then
                        exit 1                    
                    fi
                    """
                }
            }
            post {
                success {
                    echo 'Docker Image Ran Sucessfully!'
                }
                failure {
                    echo 'Docker Image Failed !'
                }
            }
        }
        stage('Deploy'){
            when {
                expression { currentBuild.currentResult == 'SUCCESS' }
            }
            steps {
                echo 'Deploying Docker Image...'
                // Deployment logic goes here
            }
        }
    }
    post {
        always {
            echo '==========================================='
            echo '   Pipeline Execution Complete'
            echo '==========================================='
            echo "Result: ${currentBuild.currentResult}"
            echo "Duration: ${currentBuild.durationString}"
            echo '==========================================='
        }
        success {
            echo 'Pipeline Completed Successfully!'
        }
        failure {
            echo 'Pipeline Failed!'
            // Uncomment for email notification:
            // emailext subject: "Build ${BUILD_NUMBER} failed",
            //          body: "Check console output at ${BUILD_URL}",
            //          to: 'team@example.com'
        }
        unstable {
            echo 'Pipeline Completed with Warnings!'
        }
        cleanup {
            echo 'Cleaning Up Docker Images...'
            sh """
                docker rmi ${DOCKER_IMAGE}:${DOCKER_TAG} 2>/dev/null || true
            """

            echo 'Cleaning Up Workspace...'
            cleanWs()
        }
    }
}
